//
//  ulibasn1Tests.m
//  ulibasn1Tests
//
//  Created by Andreas Fink on 03/07/14.
//  Copyright Â© 2017 Andreas Fink (andreas@fink.org). All rights reserved.
//

#import <XCTest/XCTest.h>
#import "ulibasn1.h"

@interface ulibasn1Tests : XCTestCase

@end

@implementation ulibasn1Tests

- (void)setUp
{
    [super setUp];
    // Put setup code here. This method is called before the invocation of each test method in the class.
}

- (void)tearDown
{
    // Put teardown code here. This method is called after the invocation of each test method in the class.
    [super tearDown];
}

- (void)testDissector
{
    const char data1[] = { /* 0x02,0x01,0x05,0x30,0x30,0x02,0x01,0x47,*/ 0x30,0x2b,0x30,0x29,0xa0,0x22,0x02,0x01,0x79,0x81,0x07,0x91,0x33,0x66,0x00,0x10,0x30,0xf1,0x82,0x07,0x83,0x97,0x36,0x59,0x07,0x00,0x00,0xa3,0x09,0x80,0x07,0x02,0xf8,0x02,0x4e,0xfd,0x4e,0x60,0x89,0x00,0xa1,0x03,0x0a,0x01,0x01 };
    
    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];
    
    NSUInteger pos = 0;
    UMASN1Object *o = [[UMASN1Object alloc]initWithBerData:data atPosition:&pos context:NULL];
    NSLog(@"ASN1 Object =\n%@",o.description);
    //XCTFail(@"No implementation for \"%s\"", __PRETTY_FUNCTION__);
}


- (void)verifyInteger:(int64_t)i64 withBytes:(uint8_t *)bytes len:(int)len
{
    NSLog(@"encoding value is %lld",i64);
    if(len == 4)
    {
        NSLog(@"should be { 0x%02x,0x%02x,0x%02x,0x%02x }",bytes[0],bytes[1],bytes[2],bytes[3]);
    }
    else if(len == 3)
    {
        NSLog(@"should be { 0x%02x,0x%02x,0x%02x }",bytes[0],bytes[1],bytes[2]);
    }
    else if(len == 2)
    {
        NSLog(@"should be { 0x%02x,0x%02x }",bytes[0],bytes[1]);
    }

    UMASN1Integer *asn1 = [[UMASN1Integer alloc]initWithValue:i64];
    NSData *data = [asn1 berEncoded];
    NSLog(@"Data is %@",data);
    
    XCTAssert(data.length == len,"encoded size mismatch");
    if(memcmp(data.bytes,bytes,len)!=0)
    {
        XCTFail(@"encoded data mismatch");
    }
    int64_t val = [asn1 value];
    NSLog(@"Decoded value is %lld",val);
    XCTAssert(val == i64,"decoded value is not equal to encoded value");
}

- (void) testBerEncodedIntegerNull
{
    int64_t value = 0;
    uint8_t bytes[] = { 0x02,0x01, 0x00 };
    [self verifyInteger:value withBytes:bytes len: sizeof(bytes)];
}

- (void) testBerEncodedInteger127
{
    int64_t value = 127;
    uint8_t bytes[] = { 0x02,0x01, 0x7F };
    [self verifyInteger:value withBytes:bytes len: sizeof(bytes)];
}


- (void) testBerEncodedInteger128
{
    int64_t value = 128;
    uint8_t bytes[] = { 0x02,0x02, 0x00, 0x80 };
    [self verifyInteger:value withBytes:bytes len: sizeof(bytes)];
}

- (void) testBerEncodedInteger256
{
    int64_t value = 256;
    uint8_t bytes[] = { 0x02,0x02, 0x01, 0x00 };
    [self verifyInteger:value withBytes:bytes len: sizeof(bytes)];
}

- (void) testBerEncodedIntegerMinus128
{
    int64_t value = -128;
    uint8_t bytes[] = { 0x02,0x01, 0x80 };
    [self verifyInteger:value withBytes:bytes len: sizeof(bytes)];
}

- (void) testBerEncodedIntegerMinus129
{
    int64_t value = -129;
    uint8_t bytes[] = { 0x02,0x02, 0xFF, 0x7F };
    [self verifyInteger:value withBytes:bytes len: sizeof(bytes)];
}

- (void) testBerEncodedIntegers
{
    int64_t i;
    for(i=-33000;i< 33000;i++)
    {
        UMASN1Integer *asn1 = [[UMASN1Integer alloc]initWithValue:i];
        int64_t val = [asn1 value];
        XCTAssert(val == i,"decoded value is not equal to encoded value for i=%lld",i);
    }
}
- (BOOL)tcapTest:(NSData *)data
{
    NSUInteger pos = 0;
    @try
    {
        UMASN1Object *o = [[UMASN1Object alloc]initWithBerData:data atPosition:&pos context:NULL];
        NSLog(@"TCAP Object =\n%@",o.description);
        return NO;
    }
    @catch(NSException *e)
    {
        NSLog(@"Exception %@",e);
        return YES;
    }

}

- (void)testTcapDecode1
{
    const unsigned char data1[] = { 0x62, 0x81, 0xCA, 0x48, 0x04, 0x46, 0x00, 0xE3, 0x20, 0x6C, 0x81, 0xC1, 0xA1, 0x81, 0xBE, 0x02, 0x01, 0x01, 0x02, 0x01, 0x2E, 0x30, 0x80, 0x80, 0x07, 0x34, 0x08, 0x12, 0x00, 0x00, 0x32, 0xF4, 0x84, 0x07, 0x91, 0x09, 0x35, 0x92, 0x10, 0x00, 0x00, 0x04, 0x81, 0x9F, 0x64, 0x0C, 0x91, 0x09, 0x35, 0x58, 0x19, 0x38, 0x46, 0x00, 0x00, 0x71, 0x70, 0x21, 0x21, 0x23, 0x05, 0x21, 0xA0, 0x05, 0x00, 0x03, 0xEB, 0x03, 0x01, 0x84, 0x41, 0x6A, 0x52, 0x9A, 0x48, 0x2E, 0x41, 0x20, 0xA8, 0x34, 0x69, 0x2D, 0x52, 0x41, 0x20, 0x2A, 0x08, 0xD4, 0x0C, 0x4E, 0x83, 0x20, 0x10, 0x54, 0x9A, 0x2C, 0x22, 0x83, 0xCC, 0x20, 0x08, 0x34, 0x05, 0x81, 0x82, 0x53, 0x64, 0x50, 0x18, 0x24, 0x06, 0x41, 0xA0, 0x24, 0x08, 0x34, 0x5D, 0x06, 0xB5, 0x41, 0x66, 0x10, 0x04, 0x12, 0x26, 0x99, 0x45, 0x6A, 0x12, 0x04, 0xB2, 0x82, 0x40, 0x4F, 0xA2, 0xB3, 0x0A, 0x02, 0x4D, 0xA9, 0x4F, 0xE9, 0xD3, 0x59, 0x05, 0x81, 0x98, 0x45, 0x6A, 0x91, 0x0A, 0x02, 0xC5, 0x6E, 0x35, 0x10, 0x88, 0xF8, 0x64, 0x06, 0xA5, 0x4F, 0x2B, 0x08, 0x54, 0x9C, 0x32, 0x93, 0x20, 0x10, 0xB5, 0x4A, 0x0C, 0x82, 0x40, 0x4F, 0xA1, 0x34, 0x48, 0x75, 0x3E, 0x41, 0xA0, 0x59, 0x0D, 0x06, 0x02, 0x11, 0x9F, 0xCC, 0xA0, 0xF4, 0x69, 0x05, 0x81, 0x9C, 0x4F, 0x10, 0x68, 0x59, 0x85, 0x26, 0xA9, 0x00, 0x00 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData1");
}

- (void)testTcapDecode2
{
    const unsigned char data1[] = { 0x48,0x04,0x79,0x23,0xb5,0x00,0x6b,0x1e,0x28,0x1c,0x06,0x07,0x00,0x11,0x86,0x05,0x01,0x01,0x01,0xa0,0x11,0x60,0x0f,0x80,0x02,0x07,0x80,0xa1,0x09,0x06,0x07,0x04,0x00,0x00,0x01,0x00,0x19,0x03,0x6c,0x7f,0xa1,0x7d,0x02,0x01,0x00,0x02,0x01,0x2c,0x30,0x75,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x02,0xf0,0x84,0x07,0x91,0x97,0x32,0x52,0x01,0x80,0xf1,0x04,0x61,0x04,0x0b,0x91,0x97,0x32,0x04,0x54,0x96,0xf6,0x00,0x08,0x71,0x70,0x11,0x02,0x83,0x20,0x82,0x4e,0x04,0x25,0x04,0x3e,0x04,0x47,0x04,0x43,0x00,0x20,0x04,0x31,0x04,0x4b,0x04,0x42,0x04,0x4c,0x00,0x20,0x04,0x42,0x04,0x32,0x04,0x3e,0x04,0x35,0x04,0x39,0x00,0x2c,0x00,0x20,0x04,0x41,0x00,0x20,0x04,0x42,0x04,0x3e,0x04,0x31,0x04,0x3e,0x04,0x39,0x00,0x20,0x04,0x38,0x00,0x20,0x04,0x34,0x04,0x3b,0x04,0x4f,0x00,0x20,0x04,0x42,0x04,0x35,0x04,0x31,0x04,0x4f,0x00,0x2e,0x00,0x2e,0x00,0x2e,0x00,0x2e };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData2");
}

- (void)testTcapDecode3
{
    const unsigned char data1[] = { 0x48,0x04,0x85,0x23,0xb5,0x00,0x6c,0x7f,0xa1,0x7d,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x75,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x02,0xf0,0x84,0x07,0x91,0x97,0x32,0x52,0x01,0x80,0xf1,0x04,0x61,0x04,0x0b,0x91,0x97,0x32,0x04,0x54,0x96,0xf6,0x00,0x08,0x71,0x70,0x11,0x02,0x83,0x20,0x82,0x4e,0x04,0x25,0x04,0x3e,0x04,0x47,0x04,0x43,0x00,0x20,0x04,0x31,0x04,0x4b,0x04,0x42,0x04,0x4c,0x00,0x20,0x04,0x42,0x04,0x32,0x04,0x3e,0x04,0x35,0x04,0x39,0x00,0x2c,0x00,0x20,0x04,0x41,0x00,0x20,0x04,0x42,0x04,0x3e,0x04,0x31,0x04,0x3e,0x04,0x39,0x00,0x20,0x04,0x38,0x00,0x20,0x04,0x34,0x04,0x3b,0x04,0x4f,0x00,0x20,0x04,0x42,0x04,0x35,0x04,0x31,0x04,0x4f,0x00,0x2e,0x00,0x2e,0x00,0x2e,0x00,0x2e };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData3");
}

- (void)testTcapDecode4
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x03,0x2a,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x85,0xf3,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x76,0x10,0x72,0xf0,0x00,0x00,0x71,0x70,0x11,0x00,0x23,0x02,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData4");
}

- (void)testTcapDecode5
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x09,0x0d,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x42,0xf7,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x69,0x59,0x42,0x31,0xf5,0x00,0x00,0x71,0x70,0x01,0x12,0x00,0x62,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData5");
}

- (void)testTcapDecode6
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x1b,0x1f,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x44,0xf0,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf2,0x04,0x59,0x24,0x0b,0x91,0x97,0x12,0x03,0x88,0x49,0xf3,0x00,0x00,0x71,0x70,0x70,0x51,0x30,0x62,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData6");
}

- (void)testTcapDecode7
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x25,0x26,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x32,0xf7,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x59,0x55,0x62,0x50,0xf8,0x00,0x00,0x71,0x70,0x70,0x22,0x35,0x64,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData7");
}

- (void)testTcapDecode8
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x33,0x00,0x43,0x0b,0x6c,0x77,0xa1,0x75,0x02,0x01,0x01,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x82,0xf4,0x84,0x07,0x91,0x09,0x35,0x92,0x10,0x00,0x00,0x04,0x59,0x20,0x0c,0x91,0x09,0x35,0x24,0x11,0x86,0x02,0x00,0x00,0x71,0x70,0x11,0x01,0x05,0x15,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData8");
}

- (void)testTcapDecode9
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x42,0x18,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x40,0xf5,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x12,0x34,0x03,0x95,0xf4,0x00,0x00,0x71,0x70,0x01,0x32,0x54,0x45,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData9");
}

- (void)testTcapDecode10
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x44,0x00,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x60,0xf5,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x12,0x73,0x01,0x77,0xf6,0x00,0x00,0x71,0x70,0x11,0x12,0x72,0x72,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData10");
}

- (void)testTcapDecode11
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x45,0x01,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x70,0xf7,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x77,0x45,0x42,0xf6,0x00,0x00,0x71,0x70,0x21,0x51,0x24,0x00,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData11");
}

- (void)testTcapDecode12
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x46,0xfe,0xb4,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x30,0xf7,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x12,0x34,0x03,0x95,0xf4,0x00,0x00,0x71,0x70,0x01,0x32,0x54,0x44,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData12");
}

- (void)testTcapDecode13
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x49,0x00,0x09,0x21,0x6c,0x77,0xa1,0x75,0x02,0x01,0x01,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x52,0xf7,0x84,0x07,0x91,0x09,0x35,0x92,0x10,0x00,0x00,0x04,0x59,0x24,0x0c,0x91,0x09,0x35,0x04,0x66,0x42,0x51,0x00,0x00,0x71,0x70,0x21,0x51,0x81,0x82,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData13");
}

- (void)testTcapDecode14
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x50,0x22,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x84,0xf2,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x69,0x29,0x57,0x89,0xf6,0x00,0x00,0x71,0x70,0x60,0x91,0x41,0x13,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData14");
}

- (void)testTcapDecode15
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x54,0x17,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x30,0xf6,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf2,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x91,0x64,0x31,0xf7,0x00,0x00,0x71,0x70,0x80,0x02,0x50,0x23,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData15");
}

- (void)testTcapDecode16
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x54,0x29,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x82,0xf1,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x02,0x18,0x07,0xf5,0x00,0x00,0x71,0x70,0x21,0x31,0x02,0x01,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData16");
}

- (void)testTcapDecode17
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x59,0x39,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x54,0xf9,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x77,0x45,0x42,0xf6,0x00,0x00,0x71,0x70,0x21,0x51,0x24,0x00,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData17");
}

- (void)testTcapDecode18
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x5a,0x0e,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x52,0xf8,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x89,0x74,0x64,0xf0,0x00,0x00,0x71,0x70,0x90,0x41,0x31,0x35,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData18");
}

- (void)testTcapDecode19
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x67,0x21,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x71,0xf8,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x20,0x0b,0x91,0x97,0x13,0x95,0x64,0x00,0xf4,0x00,0x00,0x71,0x70,0x01,0x32,0x92,0x01,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData19");
}

- (void)testTcapDecode20
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x69,0x25,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x22,0xf1,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x13,0x89,0x18,0x63,0xf4,0x00,0x08,0x71,0x70,0x21,0x41,0x92,0x05,0x21,0x46,0x00,0x20,0x04,0x3a,0x04,0x38,0x04,0x37,0x04,0x38,0x04,0x3c,0x00,0x20,0x04,0x3a,0x04,0x3e,0x04,0x34,0x04,0x38,0x04,0x3d,0x04,0x33,0x04,0x3d,0x04,0x38,0x00,0x20,0x04,0x43,0x04,0x3a,0x04,0x38,0x04,0x34,0x04,0x38,0x04,0x3d,0x04,0x33,0x04,0x3c,0x04,0x38,0x00,0x20,0x04,0x47,0x04,0x38,0x04,0x3a,0x04,0x38,0x04,0x31,0x04,0x34,0x04,0x38,0x04,0x3a,0x04,0x43 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData20");
}

- (void)testTcapDecode21
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x69,0x26,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x42,0xf5,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf2,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x89,0x74,0x64,0xf0,0x00,0x00,0x71,0x70,0x90,0x41,0x31,0x84,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData21");
}

- (void)testTcapDecode22
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x7e,0x25,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x22,0xf4,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf2,0x04,0x59,0x20,0x0b,0x91,0x97,0x99,0x26,0x56,0x39,0xf9,0x00,0x00,0x71,0x70,0x01,0x51,0x32,0x62,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData22");
}

- (void)testTcapDecode23
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x7f,0x14,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x10,0xf3,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x25,0x49,0x17,0xf7,0x00,0x00,0x71,0x70,0x70,0x31,0x33,0x72,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData23");
}

- (void)testTcapDecode24
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x89,0x1f,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x44,0xf9,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x08,0x99,0x23,0xf9,0x00,0x00,0x71,0x70,0x90,0x81,0x40,0x94,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData24");
}

- (void)testTcapDecode25
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x8a,0x33,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x93,0xf9,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x25,0x49,0x17,0xf7,0x00,0x00,0x71,0x70,0x70,0x31,0x33,0x72,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData25");
}

- (void)testTcapDecode26
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0x9d,0x0b,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x12,0xf6,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x20,0x0b,0x91,0x97,0x69,0x59,0x83,0x19,0xf7,0x00,0x00,0x71,0x70,0x80,0x22,0x42,0x62,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData26");
}

- (void)testTcapDecode27
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0xa0,0x0a,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x02,0xf7,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf2,0x04,0x59,0x20,0x0b,0x91,0x97,0x69,0x19,0x63,0x32,0xf7,0x00,0x00,0x71,0x70,0x90,0x81,0x72,0x11,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData27");
}

- (void)testTcapDecode28
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0xb4,0x2e,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x53,0xf0,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf2,0x04,0x59,0x24,0x0b,0x91,0x97,0x12,0x03,0x88,0x49,0xf3,0x00,0x00,0x71,0x70,0x70,0x51,0x10,0x24,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData28");
}

- (void)testTcapDecode29
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0xb9,0x02,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x01,0xf1,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x69,0x29,0x57,0x89,0xf6,0x00,0x00,0x71,0x70,0x60,0x91,0x41,0x13,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData29");
}

- (void)testTcapDecode30
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0xc0,0x33,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x04,0xf4,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf2,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x79,0x47,0x96,0xf0,0x00,0x00,0x71,0x70,0x11,0x02,0x75,0x11,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData30");
}

- (void)testTcapDecode31
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0xcc,0x38,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x54,0xf6,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf1,0x04,0x59,0x24,0x0b,0x91,0x97,0x02,0x53,0x54,0x76,0xf6,0x00,0x00,0x71,0x70,0x11,0x00,0x03,0x91,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData31");
}

- (void)testTcapDecode32
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0xdf,0x14,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x10,0xf7,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf2,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x79,0x47,0x96,0xf0,0x00,0x00,0x71,0x70,0x11,0x02,0x75,0x11,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };

    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];

    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData32");
}

- (void)testTcapDecode33
{
    const unsigned char data1[] = { 0x62,0x7f,0x48,0x04,0xe9,0x01,0xb5,0x00,0x6c,0x77,0xa1,0x75,0x02,0x01,0x00,0x02,0x01,0x2e,0x30,0x6d,0x80,0x07,0x34,0x08,0x12,0x00,0x00,0x80,0xf7,0x84,0x07,0x91,0x97,0x12,0x69,0x00,0x00,0xf2,0x04,0x59,0x24,0x0b,0x91,0x97,0x99,0x12,0x52,0x12,0xf9,0x00,0x00,0x71,0x70,0x01,0x22,0x95,0x70,0x21,0x50,0xcc,0x32,0xfd,0x34,0x07,0xd9,0xd3,0xe4,0xf2,0x1b,0x34,0x46,0x87,0xe9,0xa0,0xb0,0x9b,0x0c,0xa2,0x97,0xf1,0x74,0xd0,0xdb,0x0d,0x4a,0xb7,0xdf,0x21,0xd0,0xb1,0x4c,0x07,0xd1,0xd1,0x65,0x90,0x59,0x5e,0x2e,0x83,0xc2,0x70,0x38,0x08,0x4d,0xa7,0xc3,0xe7,0xba,0xd7,0xcb,0x7d,0x93,0xd9,0x6a,0xae,0x30,0x1c,0xee,0x3a,0xbf,0xdf,0xae,0x33,0xfb,0x05,0x3f,0xd6,0xd7 };
    
    NSData *data = [NSData dataWithBytes:data1 length:sizeof(data1)];
    
    XCTAssert([self tcapTest:data]==NO,"Can not decode tcapData33");
}

- (void)testBitstring1
{
    UMASN1BitString *bs = [[UMASN1BitString alloc]init];
    [bs setBit:0];
    NSData *d = bs.asn1_data;
    NSString *s1 = [d hexString];
    NSString *s2 = @"0780";
    XCTAssert ([s1 isEqualToString:s2],@"Bitstring encoding failed. Got %@ instead of %@",s1,s2);
}

- (void)testBitstring2
{
    UMASN1BitString *bs = [[UMASN1BitString alloc]init];
    [bs setBit:1];
    NSData *d = bs.asn1_data;
    NSString *s1 = [d hexString];
    NSString *s2 = @"0640";
    XCTAssert ([s1 isEqualToString:s2],@"Bitstring encoding failed. Got %@ instead of %@",s1,s2);
}

- (void)testBitstring3
{
    UMASN1BitString *bs = [[UMASN1BitString alloc]init];
    [bs clearBit:2];
    NSData *d = bs.asn1_data;
    NSString *s1 = [d hexString];
    NSString *s2 = @"0500";
    XCTAssert ([s1 isEqualToString:s2],@"Bitstring encoding failed. Got %@ instead of %@",s1,s2);
}

- (void)testBitstring4
{
    UMASN1BitString *bs = [[UMASN1BitString alloc]init];
    [bs setBit:3];
    NSData *d = bs.asn1_data;
    NSString *s1 = [d hexString];
    NSString *s2 = @"0410";
    XCTAssert ([s1 isEqualToString:s2],@"Bitstring encoding failed. Got %@ instead of %@",s1,s2);
}

- (void)testBitstring5
{
    UMASN1BitString *bs = [[UMASN1BitString alloc]init];
    [bs setBit:0];
    [bs setBit:1];
    [bs setBit:2];
    [bs setBit:3];
    [bs setBit:4];
    [bs setBit:5];
    [bs setBit:6];
    [bs setBit:7];
    [bs setBit:8];
    [bs setBit:9];
    [bs setBit:10];
    [bs setBit:11];
    [bs setBit:12];
    [bs setBit:13];
    [bs setBit:14];
    [bs setBit:15];
    NSData *d = bs.asn1_data;
    NSString *s1 = [d hexString];
    NSString *s2 = @"00FFFF";
    XCTAssert ([s1 isEqualToString:s2],@"Bitstring encoding failed. Got %@ instead of %@",s1,s2);
}

- (void) testOidEncoding
{
    NSString *testString = @"2.16.756.5.39";
    NSString *expectedHex = @"6085740527";

    UMASN1ObjectIdentifier *oid = [[UMASN1ObjectIdentifier alloc]initWithOIDString:testString];

    NSString *oidHexString = [[oid value]hexString];
    XCTAssert ([oidHexString isEqualToString:expectedHex],@"oid encoding failed. Got %@ instead of %@",oidHexString,expectedHex);
}


- (void) testOidDecoding
{
    uint8_t bytes[] =  { 0x60, 0x85, 0x74, 0x05, 0x27 };
    NSData *testData = [NSData dataWithBytes:bytes length:sizeof(bytes)];
    NSString *expectedString = @"2.16.756.5.39";


    UMASN1ObjectIdentifier *oid2 = [[UMASN1ObjectIdentifier alloc]initWithValue:testData];
    NSString *oidPrintable = [oid2 oidString];

    XCTAssert ([oidPrintable isEqualToString:expectedString],@"oid decoding failed. Got %@ instead of %@",oidPrintable,expectedString);
}

- (void) testOidDecoding2
{
    uint8_t bytes[] =  { 0x04,0x00, 0x00, 0x01, 0x00, 0x01, 0x01 };
    NSData *testData = [NSData dataWithBytes:bytes length:sizeof(bytes)];
    NSString *expectedString = @"0.4.0.0.1.0.1.1";


    UMASN1ObjectIdentifier *oid2 = [[UMASN1ObjectIdentifier alloc]initWithValue:testData];
    NSString *oidPrintable = [oid2 oidString];

    XCTAssert ([oidPrintable isEqualToString:expectedString],@"oid decoding failed. Got %@ instead of %@",oidPrintable,expectedString);

}
@end
